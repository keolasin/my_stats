{
  "hash": "28f01a2fd18a893a4201468ca63b4c5e",
  "result": {
    "markdown": "---\n# metadata\ntitle: \"Table-Top Games and Probability\"\ndescription: \"Using probability and visualizations to explore dice-rolls in combinations\"\nauthor:\n  - name: Matthew Reyes\n    url: https://blog.mreyes.info/\ndate: 09-07-2023\ncategories: [R, Probability, Visualization] # self-defined categories\ncitation: \n  url: https://blog.mreyes.info/posts/Probability/dice1.html\nimage: preview_image.jpg\nbibliography: references.bib\n\n# html formatting\nformat: \n  html:\n    code-fold: false\n\n# table of contents\ntoc: true\ntoc-expand: true\ntoc-depth: 3\n\n# draft\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n\n---\n\n::: {.cell hash='dice1_cache/html/renv-setup_b0068c26b1e75f66b3be2bb1455f809e'}\n\n:::\n\n\n\n## Background\n\nSome friends started playing the new Baldur's Gate game, a video-game based on Dungeon's and Dragons. These pen and pencil board games famously use a lot of math and statistics, and keeping track of all the interactions can quickly get dizzying. When attacking a monster in the game, one might use a weapon where the damage dealt is based on the roll of a single die, or multiple dice. It can get complicated when assessing whether damage is even going to be dealt (whether the player swung and missed, or swung and hit), or when there are modifiers like critical misses, hits, or additional bonuses applied, but getting a basic sense of average damage dealt by certain weapons over the course of a game can help players.\n\n## Question\n\nA quick question they posed was, which is better: a weapon that deals 1d12 damage (rolling a twelve-sided die, once) or 2d6 (rolling a six-sided die, twice)? We can use R with some simple visualizations and data-generating processes to simulate these scenarios to inform our players.\n\n## Data Generation\n\n### Twelve-sided die\n\nFirst, let's simulate the random roll of a twelve-sided die. It has equal chance of landing on numbers 1-12, and we'll roll the die 1000 times.\n\n\n::: {.cell hash='dice1_cache/html/single-die_cc4d2f80878dfecea6ac518d5ef5a05a'}\n\n````{.cell-code}\n```{{r single-die}}\nn <- 1000                                # <1>\nd12 <- sample(1:12, n, replace = TRUE)  # <2>\ndf.1d12 <- as.data.frame(table(d12))    # <3>\n```\n````\n:::\n\n\n1.  The number of times we want to roll our die\n2.  Using the function `sample()`, we create a vector with of our random sample, of size n, for possible outcomes provided (numbers 1-6). We set replace to `TRUE` because we can roll any given number on any subsequent roll - set to false, it would remove an outcome once it has been rolled.\n3.  Storing our result in a dataframe for plotting later.\n\n### Two six-sided dice\n\nNext, let's simulate the two six-sided dice in a similar fashion:\n\n\n::: {.cell hash='dice1_cache/html/two-dice_0c3d434312b00daf0ae7262c4bedd5b1'}\n\n````{.cell-code}\n```{{r two-dice}}\nd6 <- sample(1:6, n, replace = TRUE) + sample(1:6, n, replace = TRUE)\ndf.2d6 <- as.data.frame(table(d6))\n```\n````\n:::\n\n\n### Prep for Visualization\n\nWe created two dataframes of our generated data, `df.1d12` and `df.2d6`. Let's add some descriptive names to our outcomes (the numbers rolled) and the frequency of each outcome in the `n` trials.\n\n\n::: {.cell hash='dice1_cache/html/unnamed-chunk-1_67a04a41b25243ce697d55b5f8171d78'}\n\n````{.cell-code}\n```{{r}}\nlibrary(tidyverse)\ncolumn_names <- c(\"outcome\", \"count\")\ncolnames(df.1d12) <- column_names\ncolnames(df.2d6) <- column_names\n\ndf.1d12 <- df.1d12 %>%\n  mutate(\n    probability = count / n,\n    source = \"1d12\"\n  )\n\ndf.2d6 <- df.2d6 %>%\n  mutate(\n    probability = df.2d6$count / n,\n    source = \"2d6\"\n  )\n\ncombined_df <- rbind(df.1d12, df.2d6)\n```\n````\n:::\n\n\n## Visualize\n\nLet's create two, side-by-side histograms to examine the relative frequency of each outcome.\n\n\n::: {.cell hash='dice1_cache/html/fig-charts_1e4f9891dcafccff5e5c8b86c5cf52e1'}\n\n````{.cell-code  code-fold=\"true\"}\n```{{r}}\n#| code-fold: true\n#| label: fig-charts\n#| fig-cap: \"Charts\"\nlibrary(ggplot2)\n\ntitle_text <- sprintf(\n  \"Simulating %.f rolls for 1d12 vs 2d6\", \n  n\n)\ncaption_text <- sprintf(\n  \"Mean for 12-sided die: %.2f. Mean for 2, 6-sided dice: %.2f\", \n  mean(d12), \n  mean(d6)\n)\n\nggplot(combined_df, aes(x = outcome, y = probability, fill = source)) +\n  geom_bar(stat = \"identity\") +\n  geom_vline(data = subset(combined_df, source == \"2d6\"), aes(xintercept = mean(d6)), color = \"blue\", linetype = \"dashed\")+\n  geom_vline(data = subset(combined_df, source == \"1d12\"), aes(xintercept = mean(d12)), color = \"red\", linetype = \"dashed\")+\n  labs(\n    title = title_text,\n    x = \"Outcome\",\n    y = \"Relative Frequency\",\n    fill = \"Source\",\n    caption = caption_text\n  ) + \n  theme_minimal() +\n  facet_wrap(~ source, ncol=2)\n```\n````\n\n::: {.cell-output-display}\n![Charts](dice1_files/figure-html/fig-charts-1.png){#fig-charts width=80%}\n:::\n:::\n\n\nBased on the above, we can see that the 1d12 has an equal chance of hitting outcomes 1 through 12 (approximately uniformly distributed based on our simulation), while the 2d6 approximately follows a normal distribution. The 1d12 will hit higher and lower numbers more frequently than the 2d6, but because the 2d6 can never have an outcome of 1, it will, on average, deal more damage.\n\n\n::: {.cell hash='dice1_cache/html/env-save_b160d6e82fbce16aeeb5695f95fcd36f'}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\r\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}